---
title: "[study] 210927 스터디 기록 handler 폴더"
tags:
- log
categories:
- log
date: '2021-09-28 10:39:00'
classes: wide
---

## 서블릿 Filter
- 톰캣의 Filter (web.xml)
- Sevlet이 실행되기 전에 먼저 실행됨
- 권한이 있으면 요청을 수락하고, 권한이 없으면 요청을 거부 할수 있게 해줌
- 인증 및 권한에 따라 Servlet 을 실행 및 거부 할수 있게 해줌, 일종의 수문장 역할 (if 문 같이)

- web.xml 을 수정해서 필터 설정을 하거나, 어노테이션을 이용해서 필터 설정을 할수 있음





## 스프링 Intercept
- 스프링 자체에서 실행하는 기능
- 스프링 컨테이너가 들고 있는 Filter (Intercept)


<br/>
<br/>


**handler/PillFilter.java**

```java
package kr.co.inphrcare.study.handler;

import lombok.extern.slf4j.Slf4j;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
public class PillFilter implements Filter {
/*
스프링 필터 (Filter)
-	HTTP 요청과 응답을 변경할 수 있는 재사용가능한 코드

- 	여러 개의 필터가 모여 하나의 체인(chain; 또는 사슬)을 형성할 수도 있다. 클라이언트 - 필터1 - 필터2 - 필터3 - 자원

-	애플리케이션의 HTTP 요청 및 응답을 가로채는 데 사용되는 개체. 필터를 사용하여 두 인스턴스에서 두 가지 작업을 수행 할 수 있다.
	client의 요청을 가로채어 작업을 수행할 수 있다.
	response 되기 전에 가로채어 작업을 수행할 수 있다.
	Request/Response의 처리를 chain 하는 것에 대한 이해를 요구

 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		/*
		doFilter()
		- 서블릿에 요청 및 응답이 오면 블록 안에있는 코드 실행
		- 필터체인으로 연결하여 준다. 체인의 경우 순서를 지정할 수 있다. 체인의 가장 마지막에는 클라이언트가 요청한 최종 자원이 위치한다.
		1. request 파리미터를 이용하여 요청의 필터 작업 수행, reponse 파라미터를 이용하여 응답의 필터 작업 수행
        2. 체인의 다음 필터 처리
		 */




		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse res = (HttpServletResponse) response;
		res.addHeader("Access-Control-Allow-Origin", "*");
		/** addHeader(name, value)
		 * 주어진 이름과 정수 값으로 응답 헤더를 설정합니다. 헤더가 이미 설정된 경우 새 값이 이전 값을 덮어씁니다.
		 * <code>containsHeader</code> 메소드는 값을 설정하기 전에 헤더의 존재 여부를 테스트하는 데 사용할 수 있습니다.
		 *
		 * @param name - 헤더의 이름
		 * @param 값 - 할당된 정수 값
		 * @see #containsHeader
		 * @see #addIntHeader
		 *
		 *
		 *  Access-Control-Allow-Origin : *
		 *
		 */


		res.setHeader("Access-Control-Allow-Origin", "*");
		/** setHeader(name, value)
		 * 주어진 이름과 값으로 응답 헤더를 추가합니다. 이 방법을 사용하면 응답 헤더가 여러 값을 가질 수 있습니다.
		 *
		 * @param name 헤더의 이름
		 * @param 값 추가 헤더 값 옥텟 문자열을 포함하는 경우 RFC 2047에 따라 인코딩해야 합니다.
		 * (http://www.ietf.org/rfc/rfc2047.txt)
		 * @see #setHeader
		 *
		 */


		res.setHeader("Access-Control-Max-Age", "3600");
		// Access-Control-Max-Age : 3600

//		res.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE, PUT, PATCH, HEAD");
		res.setHeader("Access-Control-Allow-Methods", "*");
		res.setHeader("Access-Control-Allow-Headers", "*");
//		res.setHeader("Access-Control-Allow-Headers", "origin, x-requested-with, content-type, multipart, multipart/form-data, accept, token, version, locale");

		log.info("Logging Request  {} : {}", req.getMethod(), req.getRequestURI());

		chain.doFilter(request, response);
		// 3. chaing.doFilter() 요청을 필터링 안하고 다음 Filter에게 넘긴다.
        // 다음 필터에게 requset 및 response 를 넘기고, 그 Filter가 실행된 다음에 다시 돌아와서 밑에줄 코드 실행

		log.info("Logging Response :{}", res.getContentType());
	}


	@Override
	public void destroy() {}
	//필터가 웹 콘테이너에서 삭제될 때 호출


	@Override
	public void init(FilterConfig fc) throws ServletException {}
	//필터를 웹 콘테이너에 생성 후 초기화할 때 호출

}
```


